import os

# --- Helper Functions ---

def read_input(filename="input.md"):
    """Reads the puzzle input from the specified file."""
    
    # Check if the file exists
    if not os.path.exists(filename):
        print(f"Error: Input file '{filename}' not found.")
        print("Please ensure your puzzle input is saved in that file.")
        return None
        
    with open(filename, 'r') as f:
        # The input is a single long line, so we read the whole thing and strip whitespace
        return f.read().strip()

def generate_double_digit_candidates():
    """
    Generates all numbers N formed by repeating a block X twice (N = XX).
    Since max ID length is 10, the max block length L is 5.
    Returns a set of these invalid IDs for fast lookup.
    """
    double_digit_candidates = set()
    
    # L is the number of digits in the repeating block X (L=1 to L=5)
    for L in range(1, 6):
        # The multiplier is 10^L + 1 (e.g., L=2 gives 101, L=5 gives 100001)
        multiplier = 10**L + 1
        
        # Determine the range for the block X:
        # Smallest L-digit number (e.g., 10 for L=2)
        start_block = 10**(L - 1)
        # Largest L-digit number + 1 (e.g., 100 for L=2)
        end_block = 10**L
        
        for block_X in range(start_block, end_block):
            N = block_X * multiplier
            double_digit_candidates.add(N)
            
    return double_digit_candidates

# --- Main Solver Function ---

def solve_day2_part1(input_data):
    """
    Parses the ID ranges and calculates the sum of all invalid IDs 
    (Double-Digit candidates) that fall within those ranges.
    """
    if not input_data:
        return 0
        
    # Pre-generate the complete set of invalid IDs (our "solutions")
    candidates = generate_double_digit_candidates()
    
    ranges = input_data.split(',')
    total_invalid_id_sum = 0
    
    for r in ranges:
        if not r: continue
        
        try:
            # Parse the "Start-End" range
            start_str, end_str = r.split('-')
            start = int(start_str)
            end = int(end_str)
        except ValueError:
            # Skip any malformed ranges
            continue

        # Efficiently check the small set of candidates against the potentially huge range
        for candidate in candidates:
            # We only care about candidates that fall *inside* the current range
            if start <= candidate <= end:
                total_invalid_id_sum += candidate
            
            # Optimization: If the candidate is already larger than the end of the range,
            # we can stop processing if the 'candidates' set were strictly sorted.
            # However, since the set is small and generated by L, this loop is fast enough.
                
    return total_invalid_id_sum

# --- Execution Block ---

if __name__ == "__main__":
    # 1. Read the raw data from input.md
    puzzle_input = read_input()
    
    if puzzle_input is None:
        exit() # Exit if file reading failed
    
    # 2. Run the solver function
    result = solve_day2_part1(puzzle_input)
    
    # 3. Print the final answer
    print("-" * 30)
    print(f"Part 1 Answer (Sum of Invalid IDs): {result}")
    print("-" * 30)